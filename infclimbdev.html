<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Leap: Tower Climber (Time Trial)</title>
    <!-- Load Tailwind CSS for utility classes and structure -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game look and feel */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: #121212;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            color: #E0E0E0;
        }

        #game-container {
            background-color: #1f1f1f;
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.2);
            border: 4px solid #00FFFF;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
            height: auto;
            max-height: 90vh;
            position: relative; /* IMPORTANT for absolute positioning of settings button */
        }

        canvas {
            background-color: #000000;
            border: 2px solid #00FFFF;
            border-radius: 8px;
            touch-action: none; /* Important for preventing mobile browser gestures */
        }

        .game-ui {
            width: 100%;
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
            font-size: 0.75rem;
            text-align: center;
        }
        
        /* Timer style */
        .time-display {
            color: #FF4081; /* Pink for time */
            min-width: 150px;
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 5px solid #FF4081;
            border-radius: 10px;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 64, 129, 0.8);
            z-index: 1000;
            display: none;
        }

        /* Full-screen overlay for termination */
        .termination-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #121212; /* Black background to simulate crash */
            display: none; /* Starts hidden */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 2000;
        }

        /* NEW: Developer Menu Styles */
        .dev-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 400px;
            background: #000000;
            border: 4px solid #00FFFF;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 25px rgba(0, 255, 255, 1);
            z-index: 3000;
            font-family: 'Press Start 2P', cursive;
            color: #E0E0E0;
            display: none; /* Starts hidden */
        }
        .dev-menu h3 {
            color: #FF4081;
            margin-bottom: 20px;
            font-size: 1rem;
            text-align: center;
            border-bottom: 2px solid #FF4081;
            padding-bottom: 10px;
        }
        .dev-menu label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.7rem;
            color: #9E9E9E;
        }
        .dev-menu input[type="number"] {
            background: #1f1f1f;
            border: 1px solid #00FFFF;
            color: #E0E0E0;
            padding: 5px;
            width: 100%;
            border-radius: 4px;
            margin-bottom: 10px;
            font-family: Arial, sans-serif;
            font-size: 0.9rem;
            text-align: right;
        }
        .dev-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-top: 1px dashed #3f3f3f;
            font-size: 0.7rem;
        }

        .button-primary {
            background-color: #FF4081;
            color: #FFFFFF;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            border: none;
            box-shadow: 0 4px #C51162;
        }

        .button-primary:hover {
            background-color: #FF80AB;
        }

        .button-primary:active {
            transform: translateY(4px);
            box-shadow: 0 0 #C51162;
        }

        /* Secondary Button Style for "I'M DONE" / Toggles */
        .button-secondary {
            background-color: #3f3f3f;
            color: #E0E0E0;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            border: none;
            box-shadow: 0 4px #262626;
        }

        .button-secondary:hover {
            background-color: #525252;
        }

        .button-secondary:active {
            transform: translateY(4px);
            box-shadow: 0 0 #262626;
        }
        
        /* Toggle button (small) */
        .toggle-btn {
            width: 60px !important;
            padding: 5px 0 !important;
            margin: 0 !important;
            font-size: 0.6rem !important;
            border-radius: 4px !important;
            box-shadow: 0 2px #262626;
            transform: none; /* Reset transform for smaller shadow */
        }
        .toggle-btn.active {
            background-color: #4CAF50 !important;
            box-shadow: 0 2px #388E3C;
        }
        .toggle-btn.active:active {
            transform: translateY(2px);
            box-shadow: 0 0 #388E3C;
        }
        .toggle-btn:active {
            transform: translateY(2px);
            box-shadow: 0 0 #262626;
        }
        
        .controls-info {
            font-size: 0.6rem;
            text-align: center;
            margin-top: 10px;
            line-height: 1.5;
            color: #9E9E9E;
        }

        /* Mobile specific styles (small screens) */
        @media (max-width: 640px) {
            #game-container {
                border-radius: 0;
                border-left: none;
                border-right: none;
                max-width: 100%;
                padding: 10px 0;
                min-height: 100vh;
            }
            .game-ui {
                flex-wrap: wrap; 
                justify-content: center;
                gap: 10px;
                padding: 0 5px;
            }
            .score-display, .level-display, .time-display {
                font-size: 0.6rem;
                flex: 1 1 45%; 
                min-width: 120px;
            }
            #restartButton {
                flex: 1 1 100%; 
            }
            .button-primary, .button-secondary {
                padding: 8px 15px;
                font-size: 0.7rem;
            }
            .controls-info {
                font-size: 0.5rem;
            }
            .dev-menu {
                width: 95%;
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <h1 class="text-xl md:text-2xl font-bold mb-4 text-cyan-300">INFINITE CLIMB</h1>

    <!-- Settings Button (Top Right Corner) -->
    <button id="settingsButton" class="absolute top-2 right-2 text-cyan-300 hover:text-white transition-colors p-2 z-10">
        <!-- Inline SVG for Gear Icon (Lucide Settings) -->
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-settings">
            <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.78 1.35a2 2 0 0 0 .73 2.73l.15.08a2 2 0 0 1 1 1.73v.52a2 2 0 0 1-1 1.73l-.15.08a2 2 0 0 0-.73 2.73l.78 1.35a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 1-1.73v.18a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.78-1.35a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.73v-.52a2 2 0 0 1 1-1.73l.15-.08a2 2 0 0 0 .73-2.73l-.78-1.35a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/>
        </svg>
    </button>

    <canvas id="gameCanvas"></canvas>

    <div class="game-ui">
        <div id="scoreDisplay" class="score-display text-cyan-300">HEIGHT: 0m</div>
        <div id="timeDisplay" class="time-display">TIME: 00:00.00</div>
        <button id="restartButton" class="button-primary">RESTART</button>
        <div id="levelDisplay" class="level-display text-cyan-300">LEVEL: 1</div>
    </div>

    <div class="controls-info">
        CONTROLS: A/D or $\leftarrow$/$\rightarrow$ to Move, **W** / $\uparrow$ / SPACE to Jump (Double Jump Enabled!)
        <br/>
        DEV FLY MODE (W/S or $\uparrow$/$\downarrow$) for vertical movement.
    </div>
</div>

<!-- Game Over Message Box -->
<div id="messageBox" class="message-box">
    <h2 class="text-2xl text-red-500 mb-4">FELL TO YOUR DOOM!</h2>
    <p id="finalHeight" class="text-xl mb-2 text-white font-mono"></p>
    <p id="finalTime" class="text-xl mb-6 text-white font-mono"></p>
    <div class="flex justify-center gap-4">
        <button id="messageRestartButton" class="button-primary">RETRY</button>
        <button id="doneButton" class="button-secondary">I'M DONE</button>
    </div>
</div>

<!-- Full-screen Game Terminated Overlay -->
<div id="terminationOverlay" class="termination-overlay">
    <h2 class="text-3xl text-cyan-300 mb-8 animate-pulse">GAME TERMINATED</h2>
    <!-- This button is hidden by default and shown after 5s -->
    <button id="justKiddingButton" class="button-primary opacity-0 transition-opacity duration-500 hidden" 
            style="margin-top: 50px; font-size: 0.8rem;"></button>
</div>

<!-- Developer Menu Modal -->
<div id="devMenu" class="dev-menu">
    <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg text-cyan-300">DEV TOOLS MENU</h3>
        <!-- Close Button (X Icon) -->
        <button id="closeDevMenuButton" class="text-white hover:text-red-500 transition-colors p-1">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x">
                <path d="M18 6 6 18"/><path d="m6 6 12 12"/>
            </svg>
        </button>
    </div>

    <!-- Toggle Invincibility -->
    <div class="dev-toggle">
        <span class="text-cyan-300">Invincibility Mode:</span>
        <button id="invincibleToggle" class="button-secondary toggle-btn">OFF</button>
    </div>

    <!-- Toggle Fly Mode -->
    <div class="dev-toggle">
        <span class="text-cyan-300">Fly Mode (WASD / Arrows):</span>
        <button id="flyToggle" class="button-secondary toggle-btn">OFF</button>
    </div>

    <!-- Teleport to Height -->
    <div class="mt-4 pt-4 border-t-2 border-dashed border-gray-700">
        <label for="teleportHeight">Teleport Player (Height in meters):</label>
        <input type="number" id="teleportHeight" placeholder="e.g., 500" value="100">
        <button id="teleportButton" class="button-primary">TELEPORT TO PLATFORM</button>
    </div>

    <!-- Spawn Platform -->
    <div class="mt-4 pt-4 border-t-2 border-dashed border-gray-700">
        <span class="text-cyan-300 block mb-2">Platform Creation:</span>
        <button id="spawnPlatformButton" class="button-primary">SPAWN NEW PLATFORM ABOVE</button>
    </div>

</div>
<!-- END NEW: Developer Menu Modal -->

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const terminationOverlay = document.getElementById('terminationOverlay');
        const justKiddingButton = document.getElementById('justKiddingButton');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const messageBox = document.getElementById('messageBox');
        const finalHeightText = document.getElementById('finalHeight');
        const finalTimeText = document.getElementById('finalTime');
        const restartButton = document.getElementById('restartButton');
        const messageRestartButton = document.getElementById('messageRestartButton');
        const doneButton = document.getElementById('doneButton');

        // DEV MENU ELEMENTS
        const devMenu = document.getElementById('devMenu');
        const settingsButton = document.getElementById('settingsButton');
        const closeDevMenuButton = document.getElementById('closeDevMenuButton');
        const invincibleToggle = document.getElementById('invincibleToggle');
        const flyToggle = document.getElementById('flyToggle');
        const teleportHeightInput = document.getElementById('teleportHeight');
        const teleportButton = document.getElementById('teleportButton');
        const spawnPlatformButton = document.getElementById('spawnPlatformButton');
        // END DEV MENU ELEMENTS

        // --- Game Constants ---
        const PLAYER_COLOR = '#FF9800'; 
        const PLATFORM_COLOR = '#4CAF50'; 
        const SKY_COLOR = '#000000'; 
        const PLATFORM_HEIGHT = 20;
        const GRAVITY = 0.6;
        const JUMP_VELOCITY = -12;
        const RUN_SPEED = 5;
        const MAX_JUMPS = 2; 
        const LEVEL_UP_SCORE = 50; 
        const CAMERA_Y_SMOOTHING = 0.1; 
        // UPDATED: Extreme Speed (100 m/s = 1000 units/frame)
        const FLY_VELOCITY = 1000; 

        // --- Game State ---
        let state = {
            player: {
                x: 0,
                y: 0,
                width: 30,
                height: 50,
                velX: 0,
                velY: 0,
                onGround: false,
                jumpsLeft: MAX_JUMPS,
            },
            platforms: [],
            cameraX: 0, 
            cameraY: 0, 
            maxHeightReached: 0, 
            initialY: 0, 
            initialX: 0, 
            score: 0,
            level: 1,
            keys: {
                left: false,
                right: false,
                jump: false,
                flyUp: false, 
                flyDown: false,
            },
            canJumpPress: true, 
            isGameOver: false,
            gameStarted: false, 
            startTime: 0,
            elapsedTime: 0,
            timerRunning: false,
            lastPlatformY: 0, 
            animationFrameId: null,
            canvasWidth: 0,
            canvasHeight: 0,
            // DEV MENU STATE
            isDevMenuOpen: false,
            isFlying: false,
            isInvincible: false,
        };

        // --- Utility Functions ---

        /**
         * Sets canvas dimensions based on container and screen size.
         */
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            let width = container.clientWidth - 40; 
            let height = Math.min(width * (9/16), window.innerHeight * 0.7); 

            // Set a minimum size
            width = Math.max(width, 300);
            height = Math.max(height, 200);

            canvas.width = width;
            canvas.height = height;

            state.canvasWidth = width;
            state.canvasHeight = height;
        }
        
        /**
         * Formats and updates the time display element.
         * @param {number} timeMs The time in milliseconds to display. Defaults to current elapsed time.
         */
        function updateTimeDisplay(timeMs = state.elapsedTime) {
            const totalMilliseconds = timeMs;
            const minutes = String(Math.floor(totalMilliseconds / 60000)).padStart(2, '0');
            const seconds = String(Math.floor((totalMilliseconds % 60000) / 1000)).padStart(2, '0');
            const centiseconds = String(Math.floor((totalMilliseconds % 1000) / 10)).padStart(2, '0');
            
            const formattedTime = `${minutes}:${seconds}.${centiseconds}`;
            timeDisplay.textContent = `TIME: ${formattedTime}`;
            return formattedTime;
        }

        /**
         * Generates a new random platform and adds it to the world.
         */
        function generatePlatform(lastPlatform) {
            // Horizontal movement range 
            const minMoveX = -state.canvasWidth * 0.2; 
            const maxMoveX = state.canvasWidth * 0.2;

            // Vertical climb (always generate above, smaller Y value)
            const minClimbY = -120; // Max climb up
            const maxClimbY = -50;  // Min climb up

            const minWidth = 80;
            const maxWidth = 150;

            // X position: Based on last platform's X plus random horizontal movement
            let newX = lastPlatform.x + (Math.random() * (maxMoveX - minMoveX) + minMoveX);
            
            // Implement Global Boundaries for X-Clamping
            const maxWorldHalfWidth = state.canvasWidth * 1.5; 
            const globalMaxX = state.initialX + maxWorldHalfWidth;
            const globalMinX = state.initialX - maxWorldHalfWidth;

            // Clamp newX to global boundaries 
            newX = Math.min(Math.max(newX, globalMinX), globalMaxX - maxWidth);
            
            // Y position: Must be higher (smaller Y value)
            let newY = lastPlatform.y + (Math.random() * (maxClimbY - minClimbY) + minClimbY);
            
            // Ensure platform respects minClimb
            newY = Math.max(newY, lastPlatform.y + minClimbY);


            const width = Math.random() * (maxWidth - minWidth) + minWidth;

            const newPlatform = {
                x: newX,
                y: newY,
                width: width,
                height: PLATFORM_HEIGHT,
            };

            state.platforms.push(newPlatform);
            state.lastPlatformY = newPlatform.y;
        }
        
        // DEV FUNCTION: Spawns a platform near the player
        function spawnPlatformNearPlayer() {
            const p = state.player;
            const newPlatform = {
                x: p.x - 50 + Math.random() * 100, // Spawn centered horizontally on the player
                y: p.y - 100, // Spawn 100 units above the player
                width: 120,
                height: PLATFORM_HEIGHT,
            };
            state.platforms.push(newPlatform);
            console.log('Dev: Platform spawned at Y:', newPlatform.y);
            toggleDevMenu(); // Close menu after action
        }

        /**
         * Initializes the game state and starts the game loop.
         */
        function initGame() {
            // Ensure the game UI is visible and the overlays are hidden
            gameContainer.style.display = 'flex';
            terminationOverlay.style.display = 'none';
            messageBox.style.display = 'none';
            devMenu.style.display = 'none'; // Ensure dev menu is closed

            resizeCanvas();

            // Initial ground platform setup
            const initialGroundY = state.canvasHeight - PLATFORM_HEIGHT;
            const initialGround = {
                x: state.canvasWidth / 2 - 200, 
                y: initialGroundY,
                width: 400,
                height: PLATFORM_HEIGHT,
                isGround: true // Flag to identify the infinite ground
            };

            state.player = {
                x: initialGround.x + initialGround.width / 2 - 15, 
                y: initialGround.y - 50,
                width: 30,
                height: 50,
                velX: 0,
                velY: 0,
                onGround: false,
                jumpsLeft: MAX_JUMPS, 
            };

            state.platforms = [initialGround];
            state.cameraX = state.player.x - state.canvasWidth / 2;
            state.cameraY = state.player.y - state.canvasHeight / 2;
            
            // Set initial position constants
            state.initialY = initialGroundY; 
            state.initialX = initialGround.x + initialGround.width / 2; 

            state.maxHeightReached = state.player.y;
            state.score = 0;
            state.level = 1;
            state.isGameOver = false;
            state.canJumpPress = true; 
            
            // Reset Time State
            state.gameStarted = false;
            state.startTime = 0;
            state.elapsedTime = 0;
            state.timerRunning = false;
            updateTimeDisplay(0); 
            
            // DEV STATE RESET
            state.isFlying = false;
            state.isInvincible = false;
            flyToggle.classList.remove('active');
            flyToggle.textContent = 'OFF';
            invincibleToggle.classList.remove('active');
            invincibleToggle.textContent = 'OFF';
            // Also reset keys
            state.keys.flyUp = false;
            state.keys.flyDown = false;

            // Generate initial platforms
            let currentPlatform = initialGround;
            for (let i = 0; i < 15; i++) {
                generatePlatform(currentPlatform);
                currentPlatform = state.platforms[state.platforms.length - 1];
            }

            if (state.animationFrameId) {
                cancelAnimationFrame(state.animationFrameId);
            }
            gameLoop();
        }

        // --- Game Logic ---

        /**
         * Updates the player's position, velocity, and handles input.
         */
        function updatePlayer() {
            const player = state.player;
            const maxVelX = RUN_SPEED + state.level; 

            // Check if player has moved to start the timer
            if (!state.gameStarted && (state.keys.left || state.keys.right || state.keys.jump || state.keys.flyUp || state.keys.flyDown)) {
                state.gameStarted = true;
                state.timerRunning = true;
                state.startTime = performance.now();
            }

            if (state.isFlying) {
                // Fly Mode Logic: Gravity and normal physics are suspended
                player.onGround = false;

                // Vertical Control (W/ArrowUp for Up, S/ArrowDown for Down)
                if (state.keys.flyUp) {
                    player.velY = -FLY_VELOCITY;
                } else if (state.keys.flyDown) {
                    player.velY = FLY_VELOCITY;
                } else {
                    player.velY = 0; 
                }

                // Horizontal Control (A/ArrowLeft for Left, D/ArrowRight for Right)
                if (state.keys.left) { 
                    player.velX = -FLY_VELOCITY;
                } else if (state.keys.right) { 
                    player.velX = FLY_VELOCITY;
                } else {
                    player.velX = 0; 
                }

            } else {
                // Normal Jump Mode Logic (A/D/Arrows for horizontal acceleration)

                // Apply horizontal acceleration based on keys
                if (state.keys.left) {
                    player.velX = Math.max(player.velX - 1, -maxVelX);
                } else if (state.keys.right) {
                    player.velX = Math.min(player.velX + 1, maxVelX);
                } else {
                    // Apply friction
                    player.velX *= 0.8;
                    if (Math.abs(player.velX) < 0.1) player.velX = 0;
                }

                // Normal Jump Logic (Space, W, or Up Arrow)
                if (state.keys.jump && state.canJumpPress) {
                    if (player.onGround) {
                        player.velY = JUMP_VELOCITY;
                        player.onGround = false;
                        player.jumpsLeft = MAX_JUMPS - 1; 
                    } else if (player.jumpsLeft > 0) {
                        player.velY = JUMP_VELOCITY;
                        player.jumpsLeft--; 
                    }
                    state.canJumpPress = false; 
                }

                if (!state.keys.jump) {
                    state.canJumpPress = true;
                }
                
                // Gravity
                player.velY += GRAVITY;

                // Only reset onGround if not flying
                player.onGround = false;
            }

            player.y += player.velY;
            player.x += player.velX;
        }

        /**
         * Checks for collisions between the player and platforms.
         */
        function checkCollisions() {
            // Collision checks are skipped in Fly Mode for convenience
            if (state.isFlying) return; 

            const player = state.player;

            for (let i = 0; i < state.platforms.length; i++) {
                const p = state.platforms[i];

                const colX = player.x < p.x + p.width && player.x + player.width > p.x;
                const colY = player.y < p.y + p.height && player.y + player.height > p.y;

                if (colX && colY) {
                    // Landing on top
                    if (player.velY >= 0 && (player.y + player.height - player.velY) <= p.y) {
                        player.y = p.y - player.height; 
                        player.velY = 0;               
                        player.onGround = true;        
                        player.jumpsLeft = MAX_JUMPS;  
                    }
                }
            }
        }

        /**
         * Updates the camera position, score, and manages platform generation/cleanup.
         */
        function updateWorld() {
            const player = state.player;
            const canvasW = state.canvasWidth;
            const canvasH = state.canvasHeight;

            // 1. Camera Movement
            const targetCameraX = player.x - canvasW / 2 + player.width / 2;
            state.cameraX = targetCameraX; 

            const targetCameraY = player.y - canvasH / 2 + player.height / 2;
            state.cameraY = state.cameraY * (1 - CAMERA_Y_SMOOTHING) + targetCameraY * CAMERA_Y_SMOOTHING;


            // 2. Platform Generation
            const lastPlatform = state.platforms[state.platforms.length - 1];
            
            if (lastPlatform && lastPlatform.y - state.cameraY < canvasH * 0.2) {
                 // Generate only 2 new platforms at a time
                 for (let i = 0; i < 2; i++) {
                    if (state.platforms.length > 0) {
                        generatePlatform(state.platforms[state.platforms.length - 1]);
                    }
                 }
            }

            // 3. Platform Cleanup
            // Filter out platforms that are far below the camera view, unless it's the main ground platform
            state.platforms = state.platforms.filter(p => p.isGround || p.y - state.cameraY > -canvasH * 2);

            // 4. Update Score 
            // The score always reflects the highest point reached (lowest Y value)
            if (player.y < state.maxHeightReached) {
                state.maxHeightReached = player.y;
            }
            // Score calculation (initialY - current max height) / 10 to get meters
            state.score = Math.max(0, Math.floor((state.initialY - state.maxHeightReached) / 10));

            // Level Up logic
            const newLevel = Math.floor(state.score / LEVEL_UP_SCORE) + 1;
            if (newLevel > state.level) {
                state.level = newLevel;
            }

            // 5. Game Over check: Player falls too far below the camera view
            // Check is skipped if invincible
            if (!state.isInvincible && player.y - state.cameraY > canvasH * 0.8) {
                endGame();
            }

            // Update UI
            scoreDisplay.textContent = `HEIGHT: ${state.score}m`;
            levelDisplay.textContent = `LEVEL: ${state.level}`;
        }

        // --- Drawing Functions ---

        /**
         * Draws the game world (platforms and player)
         */
        function draw() {
            // Clear the canvas
            ctx.fillStyle = SKY_COLOR;
            ctx.fillRect(0, 0, state.canvasWidth, state.canvasHeight);

            // Draw Platforms
            ctx.fillStyle = PLATFORM_COLOR;
            state.platforms.forEach(p => {
                ctx.fillRect(
                    p.x - state.cameraX,
                    p.y - state.cameraY, 
                    p.width,
                    p.height
                );
            });

            // Draw Player
            // Change color if invincible
            ctx.fillStyle = state.isInvincible ? '#00FFFF' : PLAYER_COLOR; 
            ctx.fillRect(
                state.player.x - state.cameraX,
                state.player.y - state.cameraY, 
                state.player.width,
                state.player.height
            );

        }

        // --- Game Flow Control ---

        function endGame() {
            state.isGameOver = true;
            state.timerRunning = false; // Stop the timer
            cancelAnimationFrame(state.animationFrameId);
            
            // Format and display final score and time
            finalHeightText.textContent = `Max Height: ${state.score}m (Level ${state.level})`;
            const finalTime = updateTimeDisplay(state.elapsedTime);
            finalTimeText.textContent = `Time Survived: ${finalTime}`;
            
            messageBox.style.display = 'block';
        }

        // --- Event Handlers ---
        
        // Handler for the "I'm Done" button
        function handleDone() {
            // 1. Hide the game UI and Game Over box
            gameContainer.style.display = 'none';
            messageBox.style.display = 'none';
            
            // 2. Show the termination overlay
            terminationOverlay.style.display = 'flex';
            
            // 3. Reset the kidding button state (hidden and faded)
            justKiddingButton.classList.add('hidden', 'opacity-0');
            justKiddingButton.classList.remove('opacity-100');

            // 4. Timer to show the "Just Kidding" button after 5 seconds (5000ms)
            setTimeout(() => {
                // Only show if the termination screen is still active
                if (terminationOverlay.style.display === 'flex') {
                    justKiddingButton.textContent = "just kidding, let me in";
                    justKiddingButton.classList.remove('hidden', 'opacity-0');
                    justKiddingButton.classList.add('opacity-100');
                }
            }, 5000);
        }

        // --- DEV MENU Handlers ---
        function toggleDevMenu() {
            state.isDevMenuOpen = !state.isDevMenuOpen;
            devMenu.style.display = state.isDevMenuOpen ? 'block' : 'none';
        }

        /**
         * UPDATED: Teleports the player to the nearest platform relative to the input height.
         */
        function handleTeleport() {
            const heightMeters = parseFloat(teleportHeightInput.value);

            if (isNaN(heightMeters) || heightMeters < 0) {
                teleportHeightInput.value = 'Invalid!';
                setTimeout(() => teleportHeightInput.value = '100', 1000);
                return;
            }

            // 1. Calculate the ideal Y coordinate (top-left of player) based on input height (10 units per meter)
            const targetPlayerTopY = state.initialY - (heightMeters * 10) - state.player.height;

            let nearestPlatform = null;
            let minDistance = Infinity;
            
            // 2. Find the platform whose top edge (p.y) is closest to where the player needs to stand.
            for (const p of state.platforms) {
                // The actual Y coordinate (top-left) of the player when standing on this platform
                const playerYOnPlatform = p.y - state.player.height; 
                
                // Calculate the distance between the desired player Y and the actual player Y
                const distance = Math.abs(targetPlayerTopY - playerYOnPlatform);

                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPlatform = p;
                }
            }
            
            // 3. Teleport the player
            if (nearestPlatform) {
                // Teleport to the top edge of the platform
                state.player.y = nearestPlatform.y - state.player.height;
                
                // Horizontal placement: Center the player on the platform
                state.player.x = nearestPlatform.x + (nearestPlatform.width / 2) - (state.player.width / 2);
                
                // Reset velocity and ground status
                state.player.velY = 0;
                state.player.velX = 0;
                state.player.onGround = true;
                state.player.jumpsLeft = MAX_JUMPS;

                // Update camera and score tracking instantly
                state.cameraY = state.player.y - state.canvasHeight / 2 + state.player.height / 2;
                state.maxHeightReached = Math.min(state.maxHeightReached, state.player.y);
                
                const actualHeightMeters = Math.floor((state.initialY - state.player.y) / 10);

                console.log(`Dev: Teleported to ${actualHeightMeters}m (Snapped to platform Y:${nearestPlatform.y}). Error: ${Math.round(minDistance / 10)} meters.`);
            }

            toggleDevMenu(); // Close menu after action
        }

        function toggleFlying() {
            state.isFlying = !state.isFlying;
            if (state.isFlying) {
                flyToggle.classList.add('active');
                flyToggle.textContent = 'ON';
                // Stop all velocity immediately
                state.player.velY = 0; 
                state.player.velX = 0;
                state.player.jumpsLeft = MAX_JUMPS; 
                console.log('Dev: Fly Mode ON');
            } else {
                flyToggle.classList.remove('active');
                flyToggle.textContent = 'OFF';
                // Stop all velocity immediately when exiting fly mode
                state.player.velY = 0; 
                state.player.velX = 0;
                // Clear fly keys
                state.keys.flyUp = false;
                state.keys.flyDown = false;
                console.log('Dev: Fly Mode OFF');
            }
        }

        function toggleInvincibility() {
            state.isInvincible = !state.isInvincible;
            if (state.isInvincible) {
                invincibleToggle.classList.add('active');
                invincibleToggle.textContent = 'ON';
                console.log('Dev: Invincibility ON');
            } else {
                invincibleToggle.classList.remove('active');
                invincibleToggle.textContent = 'OFF';
                console.log('Dev: Invincibility OFF');
            }
        }
        // --- END DEV MENU Handlers ---


        function gameLoop() {
            if (state.isGameOver || state.isDevMenuOpen) {
                // Pause game loop if game over or menu open
                state.animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            // Stopwatch Logic
            if (state.timerRunning) {
                state.elapsedTime = performance.now() - state.startTime;
                updateTimeDisplay();
            }

            updatePlayer();
            checkCollisions();
            updateWorld();
            draw();

            state.animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * Unified Key Down Handler for WASD and Arrows
         */
        function handleKeyDown(e) {
            if (state.isGameOver) return;
            
            const key = e.key.toLowerCase();
            // Prevent default action for keys that scroll the page
            if (['arrowleft', 'arrowright', ' ', 'arrowup', 'arrowdown', 'w', 's', 'a', 'd'].includes(key)) {
                e.preventDefault();
            }
            
            // Horizontal Movement (Run and Fly Strafe)
            if (key === 'a' || key === 'arrowleft') {
                state.keys.left = true;
            } else if (key === 'd' || key === 'arrowright') {
                state.keys.right = true;
            } 
            
            // Combined Jump/Fly Up logic
            else if (key === 'w' || key === 'arrowup') {
                if (state.isFlying) {
                    state.keys.flyUp = true; // Fly Up
                } else {
                    state.keys.jump = true; // Jump when not flying (NEW)
                }
            } 
            
            // Fly Down (S/ArrowDown) - Only active in fly mode
            else if (key === 's' || key === 'arrowdown') {
                if (state.isFlying) { // Only track fly down if flying
                    state.keys.flyDown = true;
                }
            } 
            
            // Jump (Space)
            else if (key === ' ') {
                if (!state.isFlying) state.keys.jump = true;
            }
            
            // Start the timer on the first movement input
            if (!state.gameStarted && (state.keys.left || state.keys.right || state.keys.jump || state.keys.flyUp || state.keys.flyDown)) {
                state.gameStarted = true;
                state.timerRunning = true;
                state.startTime = performance.now();
            }
        }

        /**
         * Unified Key Up Handler for WASD and Arrows
         */
        function handleKeyUp(e) {
            const key = e.key.toLowerCase();

            // Horizontal Movement (Run and Fly Strafe)
            if (key === 'a' || key === 'arrowleft') {
                state.keys.left = false;
            } else if (key === 'd' || key === 'arrowright') {
                state.keys.right = false;
            } 
            
            // Combined Jump/Fly Up logic
            else if (key === 'w' || key === 'arrowup') {
                if (state.isFlying) {
                    state.keys.flyUp = false;
                } else {
                    state.keys.jump = false; // Jump release (NEW)
                }
            } 
            
            // Fly Down (S/ArrowDown) - Only active in fly mode
            else if (key === 's' || key === 'arrowdown') {
                if (state.isFlying) { // Only track fly down if flying
                    state.keys.flyDown = false;
                }
            } 
            
            // Jump (Space ONLY)
            else if (key === ' ') {
                if (!state.isFlying) state.keys.jump = false;
            }
        }
        
        // --- Initialization ---

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        window.addEventListener('resize', initGame); 

        // Main restart buttons
        restartButton.addEventListener('click', initGame);
        messageRestartButton.addEventListener('click', initGame);
        
        // Termination and Secret Comeback
        doneButton.addEventListener('click', handleDone); 
        justKiddingButton.addEventListener('click', initGame);

        // DEV MENU Event Listeners
        settingsButton.addEventListener('click', toggleDevMenu);
        closeDevMenuButton.addEventListener('click', toggleDevMenu);
        invincibleToggle.addEventListener('click', toggleInvincibility);
        flyToggle.addEventListener('click', toggleFlying); 
        teleportButton.addEventListener('click', handleTeleport);
        spawnPlatformButton.addEventListener('click', spawnPlatformNearPlayer);

        initGame(); 
    });
</script>
